using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis.Text;
#nullable enable
namespace Lucy.Core.SourceGenerator.Generators
{
    public class DbExtensionMethodGenerator
    {
        private static readonly string Ns = "Lucy.Core.SemanticAnalysis.Infrastructure";
        private static readonly Logger Logger = new Logger("extension", true);

        public static void Register(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource("HandlerExtension.g.cs", SourceText.From($$"""
                // <auto-generated/>
                #nullable enable
                namespace {{Ns}}
                {
                    [System.AttributeUsage(System.AttributeTargets.Method)]
                    public class GenerateDbExtension : System.Attribute {}
                }
                """, Encoding.UTF8)));

            if (Logger.IsEnabled)
            {
                Logger.Write("Started...");
            }

            IncrementalValuesProvider<MethodDeclarationSyntax> classDeclarationFilter = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is MethodDeclarationSyntax,
                transform: (ctx, _) => GetMethodDeclarationIfMatches(ctx))
            .Where(m => m != null)!;

            IncrementalValueProvider<(Compilation, ImmutableArray<MethodDeclarationSyntax>)> compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarationFilter.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (sps, source) =>
            {
                try
                {
                    BuildSource(sps, source.Item1, source.Item2);
                }
                catch(Exception ex)
                {
                    if (Logger.IsEnabled)
                        Logger.Write(ex.ToString());
                }
            });

        }

        static MethodDeclarationSyntax? GetMethodDeclarationIfMatches(GeneratorSyntaxContext context)
        {
            try
            {
                var methodDeclarationSyntax = (MethodDeclarationSyntax)context.Node;
                foreach (var attributeListSyntax in methodDeclarationSyntax.AttributeLists)
                {
                    foreach (var attributeSyntax in attributeListSyntax.Attributes)
                    {
                        if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol symbol &&
                            symbol.ContainingType.ToDisplayString() == Ns + ".GenerateDbExtension")
                        {
                            return methodDeclarationSyntax;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                if (Logger.IsEnabled)
                    Logger.Write("Filter crashed: " + e.ToString());
            }
            

            return null;
        }

        private static void BuildSource(SourceProductionContext sps, Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methods)
        {
            var sp = new StringBuilder();
            sp.AppendLine("// <auto-generated/>");
            sp.AppendLine("#nullable enable");


            foreach (var method in methods)
            {
                sps.CancellationToken.ThrowIfCancellationRequested();

                SemanticModel? sm;
                try
                {
                    sm = compilation.GetSemanticModel(method.SyntaxTree);
                }
                catch (ArgumentException e)
                {
                    if (Logger.IsEnabled)
                        Logger.Write("Generating " + method.Identifier.Text + " failed: " + e);
                    continue;
                }
                
                var methodInfo = sm.GetDeclaredSymbol(method);
                if (methodInfo == null)
                {
                    if (Logger.IsEnabled)
                        Logger.Write("Skipped " + method.Identifier.Text + " because the declared symbol could not be resolved.");
                    continue;
                }
                    

                var methodReturnTypeInfo = sm.GetSymbolInfo(method.ReturnType).Symbol as INamedTypeSymbol;
                
                if (methodReturnTypeInfo == null)
                {
                    if (Logger.IsEnabled)
                        Logger.Write("Skipped " + method.Identifier.Text + " because the return type symbol could not be resolved.");
                    continue;
                }

                

                var @class = method.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
                if (@class == null)
                {
                    if (Logger.IsEnabled)
                        Logger.Write("Skipped " + method.Identifier.Text + " because the class could not be resolved.");
                    continue;
                }
                    

                List<string> myArguments = new();
                List<string> handlerArguments = new();
                List<string> myMethodParameter = new();
                List<string> myRecordParameter = new();
                bool failed = false;
                foreach (var methodParameter in method.ParameterList.Parameters)
                {
                    if (methodParameter.Type == null)
                    {
                        if (Logger.IsEnabled)
                            Logger.Write("Skipped " + method.Identifier.Text + " because the parameter " + methodParameter.Identifier.Text + " type was not provided.");
                        failed= true;
                        break;
                    }
                        

                    var typeSymbol = sm.GetSymbolInfo(methodParameter.Type).Symbol as INamedTypeSymbol;
                    if (typeSymbol == null)
                    {
                        if (Logger.IsEnabled)
                            Logger.Write("Skipped " + method.Identifier.Text + " because the parameter " + methodParameter.Identifier.Text + " type symbol could not be resolved.");
                        failed = true;
                        break;
                    }
                        

                    if (typeSymbol.ToDisplayString() == Ns + ".IDb")
                        continue;

                    var fullTypeName = typeSymbol.ToDisplayString();
                    if (methodParameter.Type.ToFullString().TrimEnd().EndsWith("?"))
                        fullTypeName += "?";


                    myArguments.Add(methodParameter.Identifier.Text);
                    myMethodParameter.Add(fullTypeName + " " + methodParameter.Identifier.Text);
                    myRecordParameter.Add(fullTypeName + " " + methodParameter.Identifier.Text);
                    handlerArguments.Add("query." + methodParameter.Identifier.Text);
                }

                if (failed)
                    continue;

                handlerArguments.Insert(0, "db");
                myMethodParameter.Insert(0, $"this {Ns}.IDb db");

                var fullReturnType = methodReturnTypeInfo.ToDisplayString() + (method.ReturnType.ToFullString().TrimEnd().EndsWith("?") ? "?" : "");

                sp.AppendLine($$"""
                    namespace {{methodInfo.ContainingNamespace}}
                    {
                        public record {{method.Identifier.Text}}Input({{string.Join(", ", myRecordParameter)}}) : {{Ns}}.IQuery<{{method.Identifier.Text}}Output>;
                        public record {{method.Identifier.Text}}Output({{fullReturnType}} Result);

                        public static class {{method.Identifier.Text}}Ex
                        {
                            ///<summary>
                            ///Implementation: <see cref="{{@class.Identifier.Text}}.{{method.Identifier.Text}}" />
                            ///</summary>
                            public static {{fullReturnType}} {{method.Identifier.Text}}({{string.Join(", ", myMethodParameter)}})
                            {
                                return db.Query(new {{method.Identifier.Text}}Input({{string.Join(",", myArguments)}})).Result;
                            }
                        }

                        public class {{method.Identifier.Text}}GeneratedHandler : {{Ns}}.QueryHandler<{{method.Identifier.Text}}Input, {{method.Identifier.Text}}Output>
                        {
                            public override {{method.Identifier.Text}}Output Handle({{Ns}}.IDb db, {{method.Identifier.Text}}Input query)
                            {
                                return new {{method.Identifier.Text}}Output({{@class.Identifier.Text}}.{{method.Identifier.Text}}({{string.Join(", ", handlerArguments)}}));
                            }
                        }
                    }

                    """);
            }
            sps.AddSource("DbExtensionMethods.g.cs", SourceText.From(sp.ToString(), Encoding.UTF8));
        }

    }
}
