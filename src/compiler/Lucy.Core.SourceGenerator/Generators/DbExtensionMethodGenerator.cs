using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace Lucy.Core.SourceGenerator.Generators;

public static class DbExtensionMethodGenerator
{
    private const string _ns = "Lucy.Core.SemanticAnalysis.Infrastructure";
    private static readonly Logger _logger = new Logger("extension", true);

    public static void Register(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("HandlerExtension.g.cs", SourceText.From($$"""
                // <auto-generated/>
                #nullable enable
                namespace {{_ns}}
                {
                    [System.AttributeUsage(System.AttributeTargets.Method)]
                    public class GenerateDbExtension : System.Attribute {}
                }
                """, Encoding.UTF8)));

        if (_logger.IsEnabled)
        {
            _logger.Write("Started...");
        }

        IncrementalValuesProvider<MethodDeclarationSyntax> classDeclarationFilter = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node is MethodDeclarationSyntax,
                transform: (ctx, _) => GetMethodDeclarationIfMatches(ctx))
            .Where(m => m != null)!;

        IncrementalValueProvider<(Compilation, ImmutableArray<MethodDeclarationSyntax>)> compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarationFilter.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (sps, source) =>
        {
            try
            {
                BuildSource(sps, source.Item1, source.Item2);
            }
            catch(Exception ex)
            {
                if (_logger.IsEnabled)
                    _logger.Write(ex.ToString());
            }
        });

    }

    static MethodDeclarationSyntax? GetMethodDeclarationIfMatches(GeneratorSyntaxContext context)
    {
        try
        {
            var methodDeclarationSyntax = (MethodDeclarationSyntax)context.Node;
            foreach (var attributeListSyntax in methodDeclarationSyntax.AttributeLists)
            {
                foreach (var attributeSyntax in attributeListSyntax.Attributes)
                {
                    if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol symbol &&
                        symbol.ContainingType.ToDisplayString() == _ns + ".GenerateDbExtension")
                    {
                        return methodDeclarationSyntax;
                    }
                }
            }
        }
        catch (Exception e)
        {
            if (_logger.IsEnabled)
                _logger.Write("Filter crashed: " + e);
        }
            

        return null;
    }

    private static void BuildSource(SourceProductionContext sps, Compilation compilation, ImmutableArray<MethodDeclarationSyntax> methods)
    {
        var sp = new StringBuilder();
        sp.AppendLine("// <auto-generated/>");
        sp.AppendLine("#nullable enable");


        foreach (var method in methods)
        {
            sps.CancellationToken.ThrowIfCancellationRequested();

            SemanticModel? sm;
            try
            {
                sm = compilation.GetSemanticModel(method.SyntaxTree);
            }
            catch (ArgumentException e)
            {
                if (_logger.IsEnabled)
                    _logger.Write("Generating " + method.Identifier.Text + " failed: " + e);
                continue;
            }
                
            var methodInfo = sm.GetDeclaredSymbol(method);
            if (methodInfo == null)
            {
                if (_logger.IsEnabled)
                    _logger.Write("Skipped " + method.Identifier.Text + " because the declared symbol could not be resolved.");
                continue;
            }
                    

            var methodReturnTypeInfo = sm.GetSymbolInfo(method.ReturnType).Symbol as INamedTypeSymbol;
                
            if (methodReturnTypeInfo == null)
            {
                if (_logger.IsEnabled)
                    _logger.Write("Skipped " + method.Identifier.Text + " because the return type symbol could not be resolved.");
                continue;
            }

                

            var @class = method.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
            if (@class == null)
            {
                if (_logger.IsEnabled)
                    _logger.Write("Skipped " + method.Identifier.Text + " because the class could not be resolved.");
                continue;
            }
                    

            List<string> myArguments = new();
            List<string> handlerArguments = new();
            List<string> myMethodParameter = new();
            List<string> myRecordParameter = new();
            bool failed = false;
            foreach (var methodParameter in method.ParameterList.Parameters)
            {
                if (methodParameter.Type == null)
                {
                    if (_logger.IsEnabled)
                        _logger.Write("Skipped " + method.Identifier.Text + " because the parameter " + methodParameter.Identifier.Text + " type was not provided.");
                    failed= true;
                    break;
                }


                if (sm.GetSymbolInfo(methodParameter.Type).Symbol is not INamedTypeSymbol typeSymbol)
                {
                    if (_logger.IsEnabled)
                        _logger.Write("Skipped " + method.Identifier.Text + " because the parameter " + methodParameter.Identifier.Text + " type symbol could not be resolved.");
                    failed = true;
                    break;
                }
                        

                if (typeSymbol.ToDisplayString() == _ns + ".IDb")
                    continue;

                var fullTypeName = typeSymbol.ToDisplayString();
                if (methodParameter.Type.ToFullString().TrimEnd().EndsWith("?"))
                    fullTypeName += "?";


                myArguments.Add(methodParameter.Identifier.Text);
                myMethodParameter.Add(fullTypeName + " " + methodParameter.Identifier.Text);
                myRecordParameter.Add(fullTypeName + " " + methodParameter.Identifier.Text);
                handlerArguments.Add("query." + methodParameter.Identifier.Text);
            }

            if (failed)
                continue;

            handlerArguments.Insert(0, "db");
            myMethodParameter.Insert(0, $"this {_ns}.IDb db");

            var fullReturnType = methodReturnTypeInfo.ToDisplayString() + (method.ReturnType.ToFullString().TrimEnd().EndsWith("?") ? "?" : "");
            _logger.Write("Generating " + method.Identifier.Text);
            sp.AppendLine($$"""
                    namespace {{methodInfo.ContainingNamespace}}
                    {
                        public record {{method.Identifier.Text}}Input({{string.Join(", ", myRecordParameter)}}) : {{_ns}}.IQuery<{{method.Identifier.Text}}Output>;
                        public record {{method.Identifier.Text}}Output({{fullReturnType}} Result);

                        public static class {{method.Identifier.Text}}Ex
                        {
                            ///<summary>
                            ///Implementation: <see cref="{{@class.Identifier.Text}}.{{method.Identifier.Text}}" />
                            ///</summary>
                            public static {{fullReturnType}} {{method.Identifier.Text}}({{string.Join(", ", myMethodParameter)}})
                            {
                                return db.Query(new {{method.Identifier.Text}}Input({{string.Join(",", myArguments)}})).Result;
                            }
                        }

                        public class {{method.Identifier.Text}}GeneratedHandler : {{_ns}}.QueryHandler<{{method.Identifier.Text}}Input, {{method.Identifier.Text}}Output>
                        {
                            public override {{method.Identifier.Text}}Output Handle({{_ns}}.IDb db, {{method.Identifier.Text}}Input query)
                            {
                                return new {{method.Identifier.Text}}Output({{@class.Identifier.Text}}.{{method.Identifier.Text}}({{string.Join(", ", handlerArguments)}}));
                            }
                        }
                    }

                    """);
        }

        sps.AddSource("DbExtensionMethods.g.cs", SourceText.From(sp.ToString(), Encoding.UTF8));
    }

}