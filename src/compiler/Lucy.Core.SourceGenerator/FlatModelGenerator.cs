using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;

namespace Lucy.Core.SourceGenerator
{
    internal class FlatModelGenerator
    {
        internal static void Generate(SourceProductionContext productionContext, string name, Config config)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Collections.Immutable;");
            sb.AppendLine("using Lucy.Core.Parsing.Nodes;");
            sb.AppendLine();
            sb.AppendLine("namespace " + config.Namespace + ";");
            sb.AppendLine();

            foreach (var node in config.Nodes)
            {
                sb.AppendLine("public " + (node.IsTopMost ? "" : "abstract ") + "class Flat" + node.Name + (node.BasedOn == null ? "" : " : Flat" + node.BasedOn));
                sb.AppendLine("{");
                WriteConstructor(sb, config, node);
                WriteProperties(sb, config, node);
                WriteGetChildNodesMethod(config, sb, node);
                sb.AppendLine("}");
                sb.AppendLine();
            }

            WriteConverter(config, sb);

            productionContext.AddSource("Flat" + name + ".g.cs", sb.ToString());
        }


        private static void WriteConstructor(StringBuilder sb, Config config, Node node)
        {
            var allParameters = node
                .Properties
                .Concat(GetBaseProperties(config, node))
                .Select(x => $"{GetRealType(config, x)} {ToLower(x.Name)}")
                .ToArray();

            var baseParameters = GetBaseProperties(config, node)
                .Select(x => ToLower(x.Name))
                .ToArray();

            var paramStr = string.Join(", ", allParameters);
            var baseStr = string.Join(", ", baseParameters);

            sb.AppendLine($"    public Flat{node.Name}({paramStr}) : base(" + baseStr + ")");
            sb.AppendLine("    {");
            foreach (var prop in node.Properties)
            {
                sb.AppendLine($"        {prop.Name} = {ToLower(prop.Name)};");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        private static ImmutableArray<NodeProperty> GetBaseProperties(Config config, Node node)
        {
            if (node.BasedOn == null)
                return ImmutableArray<NodeProperty>.Empty;

            var b = ImmutableArray.CreateBuilder<NodeProperty>();
            while (true)
            {
                node = config.Nodes.FirstOrDefault(x => x.Name == node.BasedOn) ?? throw new Exception("Could not find node \"" + node.BasedOn + "\" when looking for base node for \"" + node.Name + "\"");

                b.AddRange(node.Properties);

                if (node.BasedOn == null)
                    break;
            }
            return b.ToImmutable();
        }

        private static void WriteConverter(Config config, StringBuilder sb)
        {
            sb.AppendLine("public static class ToFlatTreeConverter");
            sb.AppendLine("{");
            sb.AppendLine("    public static FlatSyntaxTreeNode ToFlat(this SyntaxTreeNode node)");
            sb.AppendLine("    {");
            sb.AppendLine("        return node switch");
            sb.AppendLine("        {");
            foreach (var node in config.Nodes.Where(x => x.IsTopMost))
            {
                sb.Append($"                {node.Name} {ToLower(node.Name)} => new Flat{node.Name}(");

                var arguments = node.Properties
                    .Concat(GetBaseProperties(config, node))
                    .Select(prop =>
                    {
                        if (prop.IsList)
                        {
                            if (IsSyntaxTreeNode(config, prop.Type))
                                return $"{ToLower(node.Name)}.{prop.Name}.Select(x => x.NodeId.ToTyped<Flat{prop.Type}>()).ToImmutableArray()";
                            else
                                return $"{ToLower(node.Name)}.{prop.Name}.ToImmutableArray()";
                        }
                        else
                        {
                            if (IsSyntaxTreeNode(config, prop.Type))
                                return $"{ToLower(node.Name)}.{prop.Name}{(prop.IsOptional ? "?" : "")}.NodeId.ToTyped<Flat{prop.Type}>()";
                            else
                                return $"{ToLower(node.Name)}.{prop.Name}";
                        }
                    })
                    .ToArray();

                var argumentsStr = string.Join(", ", arguments);
                

                sb.Append(argumentsStr);
                sb.AppendLine("),");
            }
            sb.AppendLine("                _ => throw new NotSupportedException()");
            sb.AppendLine("        };");
            sb.AppendLine("    }");
            sb.AppendLine("}");
        }

        private static string ToLower(string value)
        {
            return value.Substring(0, 1).ToLowerInvariant() + value.Substring(1);
        }

        private static string GetRealType(Config config, NodeProperty property)
        {
            var name = property.Type;

            if (IsSyntaxTreeNode(config, property.Type))
                name = "NodeId<Flat" + name + ">";

            if (property.IsOptional)
                name += "?";

            if (property.IsList)
                name = "ImmutableArray<" + name + ">";

            return name;
        }

        private static void WriteProperties(StringBuilder sb, Config config, Node node)
        {
            if (node.Properties.Count == 0)
                return;

            foreach(var prop in node.Properties)
            {
                sb.AppendLine("    public " + GetRealType(config, prop) + " " + prop.Name + " { get; }");
            }
            sb.AppendLine();
        }

        private static void WriteGetChildNodesMethod(Config config, StringBuilder sb, Node node)
        {
            if (node.BasedOn == null)
            {
                sb.AppendLine("    public abstract IEnumerable<NodeId> GetChildNodeIds();");
            }
            else
            {
                if (!node.IsTopMost)
                    return;

                sb.AppendLine("    public override IEnumerable<NodeId> GetChildNodeIds()");
                sb.AppendLine("    {");
                int count = 0;
                foreach (var prop in node.Properties)
                {
                    if (!IsSyntaxTreeNode(config, prop.Type))
                        continue;

                    var padding = "        ";
                    if (prop.IsList)
                    {
                        sb.AppendLine(padding + "foreach (var entry in " + prop.Name + ")");
                        padding += "    ";
                    }

                    if (prop.IsOptional)
                    {
                        sb.AppendLine(padding + "if (" + prop.Name + " != null)");
                        padding += "    ";

                    }

                    sb.AppendLine(padding + "yield return " + (prop.IsList ? "entry" : prop.Name) + ";");
                    count++;
                }

                if (count == 0)
                    sb.AppendLine("        yield break;");

                sb.AppendLine("    }");
            }
        }

        private static bool IsSyntaxTreeNode(Config config, string nodeName)
        {
            var node = config
                .Nodes
                .FirstOrDefault(x => x.Name == nodeName);

            return node != null;
        }
    }
}
